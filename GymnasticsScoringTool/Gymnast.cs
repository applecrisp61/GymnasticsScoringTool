using System.Runtime.Serialization;

namespace GymnasticsScoringTool {
    [DataContract]
    public class Gymnast {

        // DATA MEMBERS and PROPERTIES
        [DataMember]
        private int _numberOnTeam; // note that this is simply a number starting from 1 for each member of the team
        public int competitorNumber
        { // did not use the automatic properties here because the competitor number will be system generated by the constructor and cannot be altered
            get { return team.numberBase + _numberOnTeam; }
        }
        public string competitorNumberDisplay { get { return competitorNumber.ToString(); } }

        [DataMember]
        public string firstName { get; set; }
        [DataMember]
        public string lastName { get; set; }

        [DataMember]
        private Team _team;
        public Team team
        { // did not use the automatic properties here because I will want to add in add'l logic on the setter
            get { return _team; }
            set
            {   if(!Meet.ContainsTeam(value)) {
                    throw new Exception_TeamNotRegistered(value.name);
                }
                _team = value;
            }
        }

        [DataMember]
        private Division _division;
        public Division division
        { // did not use the automatic properties here because I will want to add in add'l logic on the setter
            get { return _division; }
            set {
                if(!Meet.ContainsDivision(value)) {
                    throw new Exception_DivisionNotImplemented(value.name);
                }
                _division = value;
            }
        }

        [DataMember]
        public EventScore vaultScore { get; set; }
        [DataMember]
        public EventScore barsScore { get; set; }
        [DataMember]
        public EventScore beamScore { get; set; }
        [DataMember]
        public EventScore floorScore { get; set; }

        public double? overallScore
        {
            get { return vaultScore + barsScore + beamScore + floorScore; }
        }
        public string overallScoreDisplay { get { return overallScore.HasValue ? overallScore.ToString() : ProgramConstants.NULL_SCORE_STRING; } }

        // this is a method, but it works tightly with all these properties
        public double? score(string eventString) {
            switch (eventString.ToUpper()) {
            case "VAULT": return vaultScore.score;
            case "BARS": return barsScore.score;
            case "BEAM": return beamScore.score;
            case "FLOOR": return floorScore.score;
            case "OVERALL":
            case "ALL-AROUND":
            case "ALL AROUND":
            case "INDIVIDUAL ALL AROUND":
            case "INDIVIDUAL ALL-AROUND":
            case "INDIVIDUAL OVERALL": return overallScore;
            default: throw new Exception_UnkownEvent(eventString.ToUpper());
            }
        }

        // To allow score comparisons (cannot use IComparable<T> interface on a Nullable<T>, which the scores
        // as currently structured inherently contain
        public double IComparableVaultScore { get { return vaultScore.score.HasValue ? vaultScore.score.Value : ProgramConstants.NULL_ICOMPARISON_SCORE; } }
        public double IComparableBarsScore { get { return barsScore.score.HasValue ? barsScore.score.Value : ProgramConstants.NULL_ICOMPARISON_SCORE; } }
        public double IComparableBeamScore { get { return beamScore.score.HasValue ? beamScore.score.Value : ProgramConstants.NULL_ICOMPARISON_SCORE; } }
        public double IComparableFloorScore { get { return floorScore.score.HasValue ? floorScore.score.Value : ProgramConstants.NULL_ICOMPARISON_SCORE; } }
        public double IComparableOverallScore { get { return overallScore.HasValue ? overallScore.Value : ProgramConstants.NULL_ICOMPARISON_SCORE; } }

        public bool IncludeInAllAroundResults
        {
            get { return vaultScore.score.HasValue && barsScore.score.HasValue && beamScore.score.HasValue && floorScore.score.HasValue; }
        }

        // CONSTRUCTORS
        public Gymnast(string fName, string lName, Team t, string divisionName) :
            this(fName, lName, Meet.GenerateNextGymnastNumberOnTeam(t), t, Meet.GetDivisionWithName(divisionName))  
            { }

        private Gymnast(string fName, string lName, int nbrOnTeam, Team t, Division d) {
            if (Meet.ContainsGymnast(fName, lName, t.name) && (fName != ProgramConstants.DEFAULT_NAME) && (lName != ProgramConstants.DEFAULT_NAME)) {
                throw new Exception_DuplicateGymnastCreationAttempt(fName, lName, t.name);
            }

            firstName = fName;
            lastName = lName;
            _team = t;
            _numberOnTeam = nbrOnTeam;
            _division = d;

            vaultScore = new EventScore(null);
            barsScore = new EventScore(null);
            beamScore = new EventScore(null);
            floorScore = new EventScore(null);
        }

        public Gymnast(Gymnast g) :
            this(g.firstName, g.lastName, g._numberOnTeam, g._team, g._division) {
            vaultScore = new EventScore(g.vaultScore.score);
            barsScore = new EventScore(g.barsScore.score);
            beamScore = new EventScore(g.beamScore.score);
            floorScore = new EventScore(g.floorScore.score);
        }


        // METHODS
        

        // METHOD OVERRIDES
        public override string ToString() {
            return firstName + " " + lastName + " (" + competitorNumber + ")";
        }
    }
}
